"use strict";(self.webpackChunkhpc_wiki=self.webpackChunkhpc_wiki||[]).push([[3568],{9877:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>d});var r=s(7624),i=s(4552);const t={sidebar_position:4,sidebar_label:"GPU",hide_table_of_contents:!0,hide_title:!0,pagination_next:null,pagination_prev:null,title:"GPU"},o=void 0,l={id:"faq/jobs/gpu",title:"GPU",description:"Job Scheduling for GPU",source:"@site/docs/faq/jobs/gpu.md",sourceDirName:"faq/jobs",slug:"/faq/jobs/gpu",permalink:"/docs/faq/jobs/gpu",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,sidebar_label:"GPU",hide_table_of_contents:!0,hide_title:!0,pagination_next:null,pagination_prev:null,title:"GPU"},sidebar:"FAQ"},a={},d=[{value:"Job Scheduling for GPU",id:"job-scheduling-for-gpu",level:2},{value:"How to schedule a GPU parallel job on Slurm?",id:"how-to-schedule-a-gpu-parallel-job-on-slurm",level:3},{value:"Example of a job script using Modulefiles",id:"example-of-a-job-script-using-modulefiles",level:4},{value:"Example of a job script using Spack",id:"example-of-a-job-script-using-spack",level:4}];function c(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"job-scheduling-for-gpu",children:"Job Scheduling for GPU"}),"\n",(0,r.jsx)(n.h3,{id:"how-to-schedule-a-gpu-parallel-job-on-slurm",children:"How to schedule a GPU parallel job on Slurm?"}),"\n",(0,r.jsxs)(n.p,{children:["Users can use the ",(0,r.jsx)(n.code,{children:"sbatch"})," command provided by Slurm to submit a job script. Note that, for loading the required packages one can use either ",(0,r.jsx)(n.code,{children:"Modulefiles"})," or ",(0,r.jsx)(n.code,{children:"Spack"}),". In the following we have shown example job scripts using ",(0,r.jsx)(n.code,{children:"Modulefiles"})," and ",(0,r.jsx)(n.code,{children:"Spack"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"example-of-a-job-script-using-modulefiles",children:"Example of a job script using Modulefiles"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n#SBATCH -p gpu\n#SBATCH -N 1\n#SBATCH -n 1\n#SBATCH --mem 512M\n#SBATCH -t 0-4:51 # time (D-HH:MM)\n#SBATCH --job-name="hello_test"\n#SBATCH -o slurm.%j.out\n#SBATCH -e slurm.%j.err\n#SBATCH --gres=gpu:1\n#SBATCH --mail-user=<username>@hyderabad.bits-pilani.ac.in\n#SBATCH --mail-type=ALL\nmodule load cuda-11.0.2\nsrun ./execname\n'})}),"\n",(0,r.jsx)(n.p,{children:"To submit the above job script use the following command."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ sbatch job.sh\n"})}),"\n",(0,r.jsx)(n.p,{children:"If you wish to test your job script and want to find when it is estimated to run, please run"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ sbatch --test-only job.sh\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that this does not actually submit the job. A detailed explanation for each code snippet of the job script ",(0,r.jsx)(n.code,{children:"job.sh"})," is given below."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is the standard convention to let the linux shell know what interpreter to run."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH -p gpu\n#SBATCH -N 1\n#SBATCH -n 1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Configuration variables for Slurm start with ",(0,r.jsx)(n.code,{children:"SBATCH"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-p"})," refers to the partition to be used by Slurm. Sharanga provides\ntwo partitions, namely, ",(0,r.jsx)(n.code,{children:"compute"})," and ",(0,r.jsx)(n.code,{children:"gpu"}),". For jobs to be executed\nexclusively on GPUs, we use the ",(0,r.jsx)(n.code,{children:"gpu"})," partition."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-N"})," represents the number of nodes to be used. In the present\nexample, we are using 1 node. Note that, at present, Sharanga has\nprovision for only one GPU node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-n"})," represents the number of tasks to be executed. For codes\nemploying distributed parallelism such as GPGPUs or hybrid parallel\nmodels based on CPUs and GPUs, users are requested to specify the\nnumber of tasks as the number of compute cores required. In the\npresent example, n is set to 1."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#SBATCH --mem 512M\n#SBATCH -t 0-4:51 # time (D-HH:MM)\n#SBATCH --job-name="hello_test"\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--mem"})," represents the maximum amount of required memory. Here, we\nare requesting 512 Megabytes of memory. Note that Slurm\nprioritises lower memory jobs over higher memory jobs in the queue.\nThis may result in delayed execution of higher memory jobs.\nTherefore, users are requested to give accurate and desirable memory\nlimits."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-t"})," represents the maximum wall clock time the job requires. Here,\nwe are requesting 0 days, 4 hours and 51 minutes. Slurm\nprioritises shorter time limit jobs over longer time limit jobs in\nthe queue. This may result in delayed execution of longer time limit\njobs. Therefore, users are requested to give accurate and desirable\ntime limits. Note that setting values greater than 24 hours will\nresult in the termination of the job by Slurm automatically."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--job-name"})," represents the name of the job."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH -o slurm.%j.out\n#SBATCH -e slurm.%j.err\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-o"})," represents ",(0,r.jsx)(n.code,{children:"stdout"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-e"})," represents ",(0,r.jsx)(n.code,{children:"stderr"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We are instructing Slurm to redirect ",(0,r.jsx)(n.code,{children:"stdout"})," and ",(0,r.jsx)(n.code,{children:"stderr"})," of the\nexecuted application to disk. For example, if your ",(0,r.jsx)(n.code,{children:"jobid"})," is 121,\nthen ",(0,r.jsx)(n.code,{children:"slurm.121.out"})," would contain the normal output of the application,\nwhile ",(0,r.jsx)(n.code,{children:"slurm.121.err"})," would contain the error output of the application.\nThese files will be stored in the directory, where the jobs were\nlaunched from."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH --gres=gpu:1\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-gres"})," represents ",(0,r.jsx)(n.code,{children:"generic resource"}),". Here, we are informing Slurm\nthat our job requires 1 GPU card of any type."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We are instructing Slurm to redirect ",(0,r.jsx)(n.code,{children:"stdout"})," and ",(0,r.jsx)(n.code,{children:"stderr"})," of the\nexecuted application to disk. For example, if your ",(0,r.jsx)(n.code,{children:"jobid"})," is 121,\nthen ",(0,r.jsx)(n.code,{children:"slurm.121.out"})," would contain the normal output of the application,\nwhile ",(0,r.jsx)(n.code,{children:"slurm.121.err"})," would contain the error output of the application.\nThese files will be stored in the directory, where the jobs were\nlaunched from."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH --mail-user=<username>@hyderabad.bits-pilani.ac.in\n#SBATCH --mail-type=ALL\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"\u2013mail-user"})," represents the email address to which job events are to\nbe delivered."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"\u2013mail-type"})," represents the type of events to be logged. Valid type\nvalues are NONE, BEGIN, END, FAIL, REQUEUE, ALL (equivalent to\nBEGIN, END, FAIL, REQUEUE, and STAGE_OUT), STAGE_OUT (burst buffer\nstage out and teardown completed), TIME_LIMIT, TIME_LIMIT_90\n(reached 90 percent of time limit), TIME_LIMIT_80 (reached 80\npercent of time limit) and TIME_LIMIT_50 (reached 50 percent of\ntime limit). Here, we have specified the event type to be ",(0,r.jsx)(n.code,{children:"ALL"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"module load cuda-11.0.2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We are using Modulefiles to set the environment needed to run our\napplication. The example application depends on ",(0,r.jsx)(n.code,{children:"CUDA"}),", which is an\nNvidia framework for allowing users to utilise GPUs."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"srun ./execname\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we are using ",(0,r.jsx)(n.code,{children:"srun"})," to start the execution of the application.\nThis is somewhat analogous to ",(0,r.jsx)(n.code,{children:"mpirun"}),". Users are requested ",(0,r.jsx)(n.strong,{children:"not"})," to\nuse ",(0,r.jsx)(n.code,{children:"mpirun"})," and instead use ",(0,r.jsx)(n.code,{children:"srun"}),". ",(0,r.jsx)(n.code,{children:"srun"})," takes care of the allocation\nand efficient management of resources via Slurm automatically."]}),"\n",(0,r.jsx)(n.h4,{id:"example-of-a-job-script-using-spack",children:"Example of a job script using Spack"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n#SBATCH -p gpu\n#SBATCH -N 1\n#SBATCH -n 1\n#SBATCH --mem 512M\n#SBATCH -t 0-4:51 # time (D-HH:MM)\n#SBATCH --job-name="hello_test"\n#SBATCH -o slurm.%j.out\n#SBATCH -e slurm.%j.err\n#SBATCH --gres=gpu:1\n#SBATCH --mail-user=<username>@hyderabad.bits-pilani.ac.in\n#SBATCH --mail-type=ALL\nspack load cuda@11.0.2\nsrun ./execname\n'})}),"\n",(0,r.jsx)(n.p,{children:"To submit the above job script use the following command."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ sbatch job.sh\n"})}),"\n",(0,r.jsx)(n.p,{children:"If you wish to test your job script and want to find when it is\nestimated to run, please run"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ sbatch --test-only job.sh\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Note that this does not actually submit the job. A detailed explanation\nfor each code snippet of the job script ",(0,r.jsx)(n.code,{children:"job.sh"})," is given below."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is the standard convention to let the linux shell know what\ninterpreter to run."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH -p gpu\n#SBATCH -N 1\n#SBATCH -n 1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Configuration variables for Slurm start with ",(0,r.jsx)(n.code,{children:"SBATCH"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-p"})," refers to the partition to be used by Slurm. Sharanga provides\ntwo partitions, namely, ",(0,r.jsx)(n.code,{children:"compute"})," and ",(0,r.jsx)(n.code,{children:"gpu"}),". For jobs to be executed\nexclusively on GPUs, we use the ",(0,r.jsx)(n.code,{children:"gpu"})," partition."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-N"})," represents the number of nodes to be used. In the present\nexample, we are using 1 node. Note that, at present, Sharanga has\nprovision for only one GPU node."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-n"})," represents the number of tasks to be executed. For codes\nemploying distributed parallelism such as GPGPUs or hybrid parallel\nmodels based on CPUs and GPUs, users are requested to specify the\nnumber of tasks as the number of compute cores required. In the\npresent example, n is set to 1."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#SBATCH --mem 512M\n#SBATCH -t 0-4:51 # time (D-HH:MM)\n#SBATCH --job-name="hello_test"\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--mem"})," represents the maximum amount of required memory. Here, we\nare requesting 512 Megabytes of memory. Note that Slurm\nprioritises lower memory jobs over higher memory jobs in the queue.\nThis may result in delayed execution of higher memory jobs.\nTherefore, users are requested to give accurate and desirable memory\nlimits."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-t"})," represents the maximum wall clock time the job requires. Here,\nwe are requesting 0 days, 4 hours and 51 minutes. Slurm\nprioritises shorter time limit jobs over longer time limit jobs in\nthe queue. This may result in delayed execution of longer time limit\njobs. Therefore, users are requested to give accurate and desirable\ntime limits. Note that setting values greater than 24 hours will\nresult in the termination of the job by Slurm automatically."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"--job-name"})," represents the name of the job."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH -o slurm.%j.out\n#SBATCH -e slurm.%j.err\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-o"})," represents ",(0,r.jsx)(n.code,{children:"stdout"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"-e"})," represents ",(0,r.jsx)(n.code,{children:"stderr"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH --gres=gpu:1\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-gres"})," represents ",(0,r.jsx)(n.code,{children:"generic resource"}),". Here, we are informing Slurm\nthat our job requires 1 GPU card of any type."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We are instructing Slurm to redirect ",(0,r.jsx)(n.code,{children:"stdout"})," and ",(0,r.jsx)(n.code,{children:"stderr"})," of the executed application to disk. For example, if your ",(0,r.jsx)(n.code,{children:"jobid"})," is 121, then ",(0,r.jsx)(n.code,{children:"slurm.121.out"})," would contain the normal output of the application, while ",(0,r.jsx)(n.code,{children:"slurm.121.err"})," would contain the error output of the application. These files will be stored in the directory where the jobs were launched from."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#SBATCH --mail-user=<username>@hyderabad.bits-pilani.ac.in\n#SBATCH --mail-type=ALL\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"\u2013mail-user"})," represents the email address to which job events are to\nbe delivered."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"\u2013mail-type"})," represents the type of events to be logged. Valid type\nvalues are NONE, BEGIN, END, FAIL, REQUEUE, ALL (equivalent to\nBEGIN, END, FAIL, REQUEUE, and STAGE_OUT), STAGE_OUT (burst buffer\nstage out and teardown completed), TIME_LIMIT, TIME_LIMIT_90\n(reached 90 percent of time limit), TIME_LIMIT_80 (reached 80\npercent of time limit) and TIME_LIMIT_50 (reached 50 percent of\ntime limit). Here, we have specified the event type to be ",(0,r.jsx)(n.code,{children:"ALL"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"spack load cuda@11.0.2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We are using Spack to set the environment needed to run our application. The example application depends on ",(0,r.jsx)(n.code,{children:"CUDA"}),", which is an Nvidia framework for allowing users to utilise GPUs."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"srun ./execname\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we are using ",(0,r.jsx)(n.code,{children:"srun"})," to start the execution of the application. This is somewhat analogous to ",(0,r.jsx)(n.code,{children:"mpirun"}),". Users are requested ",(0,r.jsx)(n.strong,{children:"not"})," to use ",(0,r.jsx)(n.code,{children:"mpirun"})," and instead use ",(0,r.jsx)(n.code,{children:"srun"}),". ",(0,r.jsx)(n.code,{children:"srun"})," takes care of the allocation and efficient management of resources via Slurm automatically."]})]})}function h(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},4552:(e,n,s)=>{s.d(n,{I:()=>l,M:()=>o});var r=s(1504);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);